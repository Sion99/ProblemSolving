# 골드5 14503. 로봇 청소기

# 로봇 청소기와 방의 상태가 주어졌을 때, 청소하는 영역의 개수를 구하라

# N*M 직사각형 방
# 각각의 칸은 벽 또는 빈칸
# 청소기는 바라보는 방향 있으며 상하좌우 중 하나

# 로봇 청소기 작동 방식
# 1. 현재 칸이 아직 청소되지 않은 경우, 현재 칸 청소
# 2. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없는 경우
#   1) 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 후진하고 1번으로 돌아감
#   2) 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다.
# 3. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우
#   1) 반시계 방향으로 90도 회전한다
#   2) 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진
#   3) 1번으로 돌아간다.

# 북, 서, 남, 동
# 서, 남, 동, 북
# 남, 동, 북, 서
# 동, 북, 서, 남

# 지금 보니까 무조건 한 칸 청소하고 꺾어야 하는 구조네
# 지그재그로 가는게 원칙이네 직선이 아니라
# ndir = [[0, 3, 2, 1], [1, 0, 3, 2], [2, 1, 0, 3], [3, 2, 1, 0]]
# dx = [[0, 1, 0, -1], [1, 0, -1, 0], [0, -1, 0, 1], [-1, 0, 1, 0]]
# dy = [[1, 0, -1, 0], [0, -1, 0, 1], [-1, 0, 1, 0], [0, 1, 0, -1]]

#   북
#서     동
#   남
# 반시계 방향으로 90도 회전한다.
# 0(북): 서(3) -> 남(2) -> 동(1) -> 북(0)
# 1(동): 북(0) -> 서(3) -> 남(2) -> 동(1)
# 2(남): 동(1) -> 북(0) -> 서(3) -> 남(2)
# 3(서): 남(2) -> 동(1) -> 북(0) -> 서(3)
# ndir = [[3, 2, 1, 0], [0, 3, 2, 1], [1, 0, 3, 2], [2, 1, 0, 3]]
# dx = [[0, -1, 0, 1], [1, 0, -1, 0], [0, 1, 0, -1], [-1, 0, 1, 0]]
# dy = [[-1, 0, 1, 0], [0, -1, 0, 1], [1, 0, -1, 0], [0, 1, 0, -1]]
# dirr = ['북', '동', '남', '서']

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

def scan(board, x, y, d, n, m):
    for dir in range(4):
        nd = (d + 3 - dir) % 4
        nx = x + dx[nd]
        ny = y + dy[nd]
        if nx < 0 or nx >= n or ny < 0 or ny >= m:
            continue
        if board[nx][ny] == 0:
            return nd, nx, ny
    return -1, -1, -1

import sys

input = sys.stdin.readline

# 방의 크기
n, m = map(int, input().rstrip().split())

# 초기 상태 (위치와 방향)
# 방향(d) 0: 북쪽(위) 1: 동쪽(오른쪽) 2: 남쪽(아래) 3: 서쪽(왼쪽)
r, c, d = map(int, input().rstrip().split())

# 0이 청소되지 않은 칸, 1은 벽, 2를 청소된 칸이라고 하자
board = []
for _ in range(n):
    board.append(list(map(int, input().rstrip().split())))

cleaned = 0
while True:
    if board[r][c] == 0:
        board[r][c] = cleaned + 2
        cleaned += 1

    nd, nx, ny = scan(board, r, c, d, n, m)

    if nd != -1:
        d = nd
        r, c = nx, ny
    else:
        back_d = (d + 2) % 4
        nr = r + dx[back_d]
        nc = c + dy[back_d]
        if 0 <= nr < n and 0 <= nc < m and board[nr][nc] != 1:
            r, c = nr, nc
        else:
            break

print(cleaned)