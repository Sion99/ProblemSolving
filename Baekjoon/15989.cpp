#include <iostream>

using namespace std;

int main() {

    // 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 4가지
    // 1 + 1 + 1 + 1
    // 2 + 1 + 1
    // 2 + 2
    // 1 + 3

    // 수 순서는 상관없음

    // 정수 n이 주어졌을 때 n을 1, 2, 3의 합으로 나타내는 방법의 수

    // DP로 풀면 됨!


    // 1 -> 1 (1개)
    // 2 -> 1 + 1, 2 (2개)
    // 3 -> 1 + 1 + 1, 1 + 2, 3 (3개)
    // 4 -> 4개
    // 5 -> 1 1 1 1 1 ,  1 2 2, 1 1 3, 1 1 1 2, 2 3 -> 5개
    // 6 -> 1*6, 1 2 3, 2 2 2, 1 1 1 1 2, 1 1 1 3, 1 1 2 2, 3 3 -> 7개
    // 7 -> 1*7, 1 3 3, 1 2 2 2, 1 1 1 1 3, 1 1 1 1 1 2, 2 2 3, 1 1 2 3, 1 1 1 2 2 -> 8개
    // 8
    // 9
    // 10 -> 14

    // 원래 구하던 것에서 중복을 제거했으니까 원래 거를 생각해보자
    // 1
    // 2 -> 1 + 1, 2
    // 3 -> 1 + 1 + 1, 1 + 2, 2 + 1, 3
    // 4 -> 1 1 1 1, 1 1 2, 1 2 1, 2 1 1, 2 2, 1 3, 3 1 -> 7
    // 5 -> 1 1 1 1 1, 1 2 2, 2 1 2, 2 2 1, 1 1 1 2, 1 1 2 1, 1 2 1 1, 2 1 1 1, 2 3, 3 2 -> 10

    // 기존이 arr[n] = arr[n -1] + arr[n - 2] + arr[n - 3] 이었다면
    // 여기는 기존값에가다 중복에 해당하는 만큼 줄여야 하는데..

    // bottom-up으로 해볼까?

    // 확실히 점화식 구하는 게 너무너무 어렵다..

    int t;
    cin >> t;

    int arr[10001] = {0, };

    arr[1] = 1;
    arr[2] = 2;
    arr[3] = 3;
    arr[4] = 4;

    for (int i = 4; i <= 10000; i++) {
        arr[i] = arr[i - 3] + (i / 2) + 1;
    }

    for (int i = 0; i < t; i++) {
        int n;
        cin >> n;
        
        cout << arr[n] << '\n';
    }       
}